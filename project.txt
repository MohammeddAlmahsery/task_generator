Project Documentation: Project "Nexus"
Document Version: 1.0
Last Updated: October 26, 2023
Author: [Your Name/Team Name]
Status: Draft

1. Business Plan & Overview
1.1. Project Title: Nexus - Centralized Internal Tool Dashboard

1.2. Problem Statement:
Acme Corp's internal teams (HR, IT, Finance) use a variety of disparate web tools (e.g., Leave Tracker, Ticket System, Expense Manager). This leads to:

Low Productivity: Employees waste time switching between different URLs and logins.

Poor User Experience: Inconsistent UI/UX across tools causes confusion.

Management Overhead: Each tool requires separate deployment, monitoring, and user management.

1.3. Solution:
Nexus will be a unified, web-based dashboard that aggregates all internal tools into a single portal. It will provide a consistent user experience, Single Sign-On (SSO), and a centralized administration panel.

1.4. Key Features (MVP - Minimum Viable Product):

Single Sign-On (SSO): One login for all integrated tools.

Unified Dashboard: A customizable homepage with widgets from different tools (e.g., "My Pending Leave Requests," "Open IT Tickets").

Tool Integration: Integrate three core tools for launch: LeaveApp, TicketFlow, and ExpenSense.

User Role Management: Admin, Manager, and Employee roles with different permissions.

Responsive UI: Works on desktop and mobile.

1.5. Success Metrics (KPIs - Key Performance Indicators):

Reduce time spent navigating between tools by 40% (measured via user surveys).

Achieve a 95% user satisfaction score for the dashboard interface.

Decrease IT support tickets related to tool access by 75%.

1.6. Target Audience: All 500 employees of Acme Corp.

2. Technical Architecture
2.1. High-Level Diagram:

text
[User's Browser]
      |
      | (HTTPS/SSL)
      v
[Cloudflare CDN & SSL Termination]
      |
      v
[NGINX Ingress Controller (K8s)] -> [Authentication Middleware]
      |
      |------------------------------|---------------------------------|
      v                              v                                 v
[Frontend Service]           [Backend API Service]             [Microservice: LeaveApp]
(Pod: React App)             (Pod: Django API)                 (Pod: Django App)
      |                              |                                 |
      |------------------------------|---------------------------------|
                                      |
                                      v
                             [PostgreSQL Database (Primary)]
                                      |
                                      v
                             [PgBouncer (Connection Pooler)]
                                      |
                                      v
                             [PostgreSQL (Read Replica)]
Diagram: A simplified view of the Kubernetes deployment with a primary focus on the main API and one example microservice.

2.2. Technology Stack:

Frontend: React 18, TypeScript, Tailwind CSS, Axios

Backend (Main API): Django 4.2, Django REST Framework, SimpleJWT for authentication

Database: PostgreSQL 15

API: RESTful APIs, Swagger/OpenAPI for documentation

Containerization: Docker

Orchestration: Kubernetes (EKS)

Cloud Provider: AWS

CI/CD: GitHub Actions

Monitoring: Prometheus, Grafana, Sentry (for error tracking)

3. Frontend (React/TypeScript) Plan
3.1. Key Components:

Login.tsx: Handles SSO authentication.

Dashboard.tsx: Fetches and displays widget data from various microservices.

WidgetLoader.tsx: A generic component that dynamically loads the correct widget based on API response.

Navbar.tsx & Sidebar.tsx: Navigation with role-based menu items.

AdminPanel.tsx: (Role-Protected) For user and widget management.

3.2. State Management: React Context API for global state (user auth info). Local state for component-specific data.

3.3. Test Data & Mocking (Development):
We will use Mock Service Worker (MSW) to intercept API calls and return realistic test data during development.

Example Mock API Response for /api/dashboard/widgets:

json
{
  "user": {
    "id": 12345,
    "name": "Jane Doe",
    "role": "manager",
    "email": "jane.doe@acme.corp"
  },
  "widgets": [
    {
      "id": "leave-widget-001",
      "type": "leave_requests",
      "title": "Pending Leave Approvals",
      "data": {
        "pending_requests": [
          { "employee_name": "John Smith", "days": 5, "start_date": "2023-11-15" },
          { "employee_name": "Alice Johnson", "days": 2, "start_date": "2023-11-20" }
        ]
      }
    },
    {
      "id": "ticket-widget-001",
      "type": "it_tickets",
      "title": "My Open Tickets",
      "data": {
        "open_tickets": [
          { "id": "TKT-1001", "title": "Monitor not working", "status": "In Progress" },
          { "id": "TKT-1002", "title": "Software license request", "status": "Open" }
        ]
      }
    }
  ]
}
4. Backend (Django) Plan
4.1. Project Structure:

text
nexus_backend/
├── config/                 # Django project settings
├── apps/
│   ├── authentication/     # Handles SSO JWT token issuance/verification
│   ├── dashboard/          # Core logic for assembling dashboard data
│   └── users/              # User model and profile management
├── microservices_client/   # Module containing clients to talk to other services (LeaveApp, TicketFlow)
└── utils/                  # Common utilities (loggers, API callers)
4.2. Key Models (Sample):

User (Extends Django's AbstractUser): id, username, email, role, department.

UserDashboardWidget: id, user (FK), widget_type, position_config.

4.3. Key APIs (Endpoints):

POST /api/auth/login/: Accepts LDAP/AD credentials, returns JWT tokens.

GET /api/dashboard/: Returns the personalized dashboard configuration and data for the authenticated user.

POST /api/dashboard/widgets/: Allows users to add a new widget to their dashboard.

GET /api/admin/users/: (Admin only) List all users.

4.4. Test Data (Database Fixtures):
A fixture file initial_data.json will be loaded for staging and development environments.

json
[
  {
    "model": "users.user",
    "pk": 1,
    "fields": {
      "password": "pbkdf2_sha256$...",
      "last_login": null,
      "is_superuser": true,
      "username": "admin",
      "email": "admin@acme.corp",
      "role": "admin",
      "department": "IT"
    }
  },
  {
    "model": "users.user",
    "pk": 2,
    "fields": {
      "password": "pbkdf2_sha256$...",
      "last_login": null,
      "is_superuser": false,
      "username": "jane.doe",
      "email": "jane.doe@acme.corp",
      "role": "manager",
      "department": "Finance"
    }
  }
]
5. Database (PostgreSQL) Plan
5.1. Database Schema (Simplified):

sql
CREATE TABLE users_user (
    id SERIAL PRIMARY KEY,
    password VARCHAR(128) NOT NULL,
    last_login TIMESTAMP WITH TIME ZONE NULL,
    is_superuser BOOLEAN NOT NULL,
    username VARCHAR(150) NOT NULL UNIQUE,
    email VARCHAR(254) NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('employee', 'manager', 'admin')),
    department VARCHAR(100)
);

CREATE TABLE dashboard_userdashboardwidget (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users_user(id) ON DELETE CASCADE,
    widget_type VARCHAR(50) NOT NULL,
    position_config JSONB NOT NULL
);
5.2. Security:

Database passwords will be managed using Kubernetes Secrets.

Connections will be encrypted using TLS.

PgBouncer will be used to pool connections and prevent overload.

6. Deployment & DevOps Plan
6.1. Infrastructure as Code (IaC):

Terraform will be used to provision the core AWS infrastructure: VPC, EKS cluster, RDS PostgreSQL instance, S3 buckets.

6.2. Containerization:

Each service (Frontend, Backend, Microservices) will have its own Dockerfile.

Example Dockerfile for backend:

dockerfile
FROM python:3.11-slim-bookworm
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
RUN python manage.py collectstatic --noinput
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "config.wsgi:application"]
6.3. Kubernetes Manifests:

Each application will have dedicated manifests for Deployment, Service, and HorizontalPodAutoscaler.

Example Backend Deployment (deployment.yaml):

yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nexus-backend
  namespace: nexus
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nexus-backend
  template:
    metadata:
      labels:
        app: nexus-backend
    spec:
      containers:
      - name: django-app
        image: 123456789012.dkr.ecr.us-west-2.amazonaws.com/nexus-backend:git-abc1234
        ports:
        - containerPort: 8000
        envFrom:
        - secretRef:
            name: nexus-backend-secrets
        livenessProbe:
          httpGet:
            path: /api/health/
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
6.4. CI/CD Pipeline (GitHub Actions):

yaml
name: Deploy to EKS Staging

on:
  push:
    branches: [ "main" ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Backend Tests
        run: docker build -t backend-test -f Dockerfile.test .
      - name: Run Frontend Tests
        run: |
          cd frontend
          npm ci
          npm test -- --coverage --watchAll=false

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with: { ... }
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build, tag, and push backend image to ECR
        run: |
          docker build -t ${{ secrets.ECR_BACKEND_REPO }}:latest -t ${{ secrets.ECR_BACKEND_REPO }}:${{ github.sha }} .
          docker push ${{ secrets.ECR_BACKEND_REPO }} --all-tags

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
      - name: Deploy to EKS
        run: |
          aws eks update-kubeconfig --name nexus-cluster-staging --region us-west-2
          kubectl apply -f k8s/manifests/ --namespace nexus
          kubectl rollout restart deployment/nexus-backend -n nexus
          kubectl rollout status deployment/nexus-backend -n nexus
6.5. Deployment Strategy:

Staging: Automated deployments on push to main branch.

Production: Manual trigger from GitHub Actions UI for deployment from production branch. Will use a blue-green deployment strategy to minimize downtime.